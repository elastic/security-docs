[[timeline-object-schema]]
[role="xpack"]
== Timeline object schema

[width="100%",options="header"]
|==============================================
|Name |Type |Description

|`columns` |<<col-obj, columns[]>> |The timeline columns displayed in the UI.
|`created` |Float |The time the timeline was created, using a 13-digit Epoch
timestamp.
|`createdBy` |String |The user who created the timeline.
|`dataProviders` |<<dataProvider-obj, dataProviders[]>> |Object that represents
each individual dropzone query statement that determines which events are
displayed in the timeline.
|`dateRange` |Object |The timeline's range.
|`description` |String |The timeline's description.
|`eventNotes` |<<eventNotes-obj, eventNotes[]>> |Notes added to specific
events in the timeline.
|`eventType` |String a|Event types displayed in the timeline, which can be:

* `all`: all events
* `raw`: raw events only
* `signal`: signals only

|`favorite` |<<favorite-obj, favorite[]>> |Indicates who marked a timeline as a
favorite, and at what time.
|`filters` |<<filters-obj, filters[]>> |Filters used in addition to the
dropzone query (`+ Add filter` option in the UI).
|`globalNotes` |<<globalNotes-obj, Object[]>> |Notes added to the timeline.
|`kqlMode` |String a|Indicates whether the KQL bar filters the dropzone query
results or searches for additional results, where:

* `filter`: filters dropzone query results
* `search`: displays additional search results

|`kqlQuery` |<<kqlQuery-obj, kqlQuery>> |Object describing the KQL bar query.
|`pinnedEventIds` |pinnedEventIds[] |Object containing the IDs of pinned
events.
|`savedObjectId` |String |The timeline's saved object ID.
|`savedQueryId` |String |If used, the saved query ID used to filter or search
dropzone query results.
|`sort` |sort a|Object indicating how rows are sorted in the timeline's grid:

* `columnId` (string): The ID of the column used to sort results.
* `sortDirection` (string): The sort direction, which can be either `desc` or
`asc`.

|`status` |String |: ???
|`templateTimelineId` |String |: ???
|`templateTimelineVersion` |Integer |: ???
|`timelineType` |String a|Indicates whether the timeline is a template or not,
where:

* `default`: Indicates a timeline used to actively investigate events.
* `template`: Indicates a timeline template used with detection rules for
displaying alerts in Timeline.

|`title` |String |The timeline's title.
|`updated` |Float |The last time the timeline was updated, using a
13-digit Epoch timestamp.
|`updatedBy` |String |The user who last updated the timeline.
|`version` |String |The timeline's version.
|==============================================

[[col-obj]]
[discrete]
==== columns object

[width="100%",options="header"]
|==============================================
|Name |Type |Description

|`aggregatable` |Boolean |Indicates whether the column field header can be
aggregated on all indices.
|`category` |String |The ECS field set to which the column field header belongs.
|`description` |String |UI column field description tooltip.
|`example` |String |UI column field example tooltip.
|`indexes` |String |List of indices where the column field header has the same
type, or null if all indices have the same type for the field.
|`id` |String |ECS field alias or user defined field name for the column header.
|`name` |String |Reserved for future use, typically `null`.
|`searchable` |Boolean |Indicates whether the column field header is indexed
for search on all indices.
|`type` |String |Column field header type.
|==============================================

[[dataProvider-obj]]
[discrete]
==== dataProviders object

[width="100%",options="header"]
|==============================================
|Name |Type |Description

|`and` |dataProviders[] |Array containing statements using `AND` logic.
|`id` |String |The dropzone query statement's unique ID.
|`name` |String |The dropzone query statement's name (the statement's value
when timelines are exported).
|`enabled` |Boolean |Indicates if the dropzone query statement is enabled.
|`excluded` |Boolean |Indicates if the dropzone query statement uses `NOT`
logic.
|`kqlQuery` |String |Always empty.
|`queryMatch` |QueryMatchInput a|The dropzone query statement:

* `displayField`: ???
* `displayValue`: ???
* `field`: The field used to filter results.
* `operator`: The statements operator.
* `value`: The field value used to match results.

|==============================================

[[eventNotes-obj]]
[discrete]
==== eventNotes object

[width="100%",options="header"]
|==============================================
|Name |Type |Description

|`created` |Float |The time the note was created, using a 13-digit Epoch
timestamp.
|`createdBy` |String |The user who added the note.
|`eventId` |String |The ID of the event to which the note was added.
|`note` |String |The note's text.
|`noteId` |String |The note's ID
|`timelineId` |String |The ID of the timeline to which the note was added.
|`updated` |Float |The last time the note was updated, using a
13-digit Epoch timestamp.
|`updatedBy` |String |The user who last updated the note.
|`version` |String |The note's version.
|==============================================

[[favorite-obj]]
[discrete]
==== favorite object

[width="100%",options="header"]
|==============================================
|Name |Type |Description

|`favoriteDate` |Float |The time the timeline was marked as a favorite.
|`fullName` |String |The full name of the user who marked the timeline as
a favorite.
|`keySearch` |String |???
|`userName` |String |The {kib} username of the user who marked the
timeline as a favorite.
|==============================================

[[filters-obj]]
[discrete]
==== filters object

[width="100%",options="header"]
|==============================================
|Name |Type |Description

|`exists` |String |Field exists query, or `null` when not defined.
|`meta` |FilterMetaTimelineInput a|Object containing filter details:

* `alias`: UI filter name.
* `disabled`: Indicates if the filter is disabled.
* `field`: ???
* `key`: Field used for filtering results.
* `negate`: Indicates if the filter query statement uses `NOT` logic.
* `params`: Query values ???
* `type`: Type of filter.
* `value`: 

|`match_all` |String |???
|`missing` |String |???
|`query` |String |???
|`range` |String |???
|`script` |String |???
|==============================================

[[globalNotes-obj]]
[discrete]
==== globalNotes object

[width="100%",options="header"]
|==============================================
|Name |Type |Description

|`created` |Float |The time the note was created, using a 13-digit Epoch
timestamp.
|`createdBy` |String |The user who added the note.
|`note` |String |The note's text.
|`noteId` |String |The note's ID
|`timelineId` |String |The ID of the timeline to which the note was added.
|`updated` |Float |The last time the note was updated, using a
13-digit Epoch timestamp.
|`updatedBy` |String |The user who last updated the note.
|`version` |String |The note's version.
|==============================================

[[kqlQuery-obj]]
[discrete]
==== kqlQuery object

[width="100%",options="header"]
|==============================================
|Name |Type |Description

|`filterQuery` |filterQuery a|Object containing query details:

* `kuery`: Object containing the query's statements and type:
** `expression`(string): The query's statements.
** `kind` (string): The type of query, which can be `kuery` or `lucene`.
* `serializedQuery` (string): The query represented in JSON format.
|==============================================
